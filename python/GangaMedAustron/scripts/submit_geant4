# GangaMedAustron - Dietrich Liko, August 2009
#
# Submit an installation job
#

import os, re
import logging

import GangaMedAustron

def read_macro(name):
    '''
    Read the beamon command from the macro file
    '''

    beamon = re.compile('^/run/beamOn\W+(\d+)')
    for line in file(name):
        match = beamon.match(line)
        if match:
            return int(match.group(1))

def write_macro(macro,events,tmpdir):
    '''
    Write macro with updated number of events
    '''

    macro_name = os.path.join(tmpdir,os.path.basename(macro))
    out = open(macro_name,'w')

    beamon = re.compile('^/run/beamOn\W+(\d+)')
    for line in file(macro):
        match = beamon.match(line)
        if match:
            print >>out,"/run/beamOn %d" % events
        else:
            print >>out,line,
    
    return macro_name

def write_tarball(package,tmpdir):
    '''
    Wrap up the package as a tarball
    '''

    import tarfile

    dir, name = os.path.split(package)
    tarball_name = os.path.join(tmpdir,'%s.tar.gz' % name)

    cwd = os.getcwd()
    os.chdir(dir)

    tarball = tarfile.open(tarball_name,'w:gz')
    tarball.add(name,recursive=True)
    tarball.close()

    return tarball_name

def getFile(name):

    return File(os.path.abspath(os.path.join(os.path.dirname(GangaMedAustron.__file__),name)))
 
def gridrun_job(package,macro,subjobs,output,ce):
    '''
    Submit a GEANT4 job
    '''

    job = Job()
    job.application = Executable()
    job.application.exe = getFile('share/gridrun_geant4.sh')
    job.inputsandbox = [ File(package), 
                         File(macro), 
                         getFile('share/install_geant4.sh'),
                         getFile('share/MD5SUM'),
                         getFile('share/patch1'),
                         getFile('share/patch2') ]
    if output: job.outputsandbox = output
    job.backend = LCG()
    if ce: job.backend.CE = ce
   
    package_name = os.path.basename(package)
    macro_name = os.path.basename(macro)

    if subjobs < 2:
        job.application.args = [ '%s %s' % (package_name, macro_name) ]
    else:     
        job.splitter = ArgSplitter()
        import random
        for i in range(subjobs):
            job.splitter.args.append(['%s %s %d' % (package_name, macro_name, random.randint(0,900000000))])

    return job

if __name__ == '__main__':

    from optparse import OptionParser

    parser = OptionParser(usage = 'usage: %prog [options] package macro',
                          description='Submit jobs to run GEANT4 for MedAustron on VOCE sites')

    parser.add_option('--any',
                      dest='any',default=False,action='store_true',
                      help='Run jobs on any CE in VOCE')

    parser.add_option('--CE',
                      dest='CE', type='string', action='store',
                      help='Force job to run at a specific CE')

    parser.add_option('-o','--output',
                      dest='output',type='string',action='append',
                      help='Output file name')

    parser.add_option('--events',
                      dest='events',type='int',action='store',
                      help='Number of events to simulate')
   
    parser.add_option('--events-per-job',
                      dest='events_per_job',type='int',action='store',
                      help='Number of events per job')

    parser.add_option('--split',
                      dest='split',type='int',action='store',
                      help='Split into subjobs')

    parser.add_option('-v','--verbose',
                      dest='verbose',default=False,action='store_true',
                      help='Make submission more verbose')

    options, args = parser.parse_args()

    if options.any and options.CE:
        parser.options('Options --any and --CE are mutally exclusive.')

    if options.split and options.events_per_job:
        parser.error('Options --split and --events_per_job are mutually exclusive.')

    if options.CE:
        ce = options.CE
    elif options.any:
        ce = ''
    else:
        ce = 'hephygr.oeaw.ac.at:2119/jobmanager-lcgpbs-voce'

    if len(args) != 2:
        parser.error('Wrong number of arguments')

    logger = logging.getLogger('submit_geant4')
    if options.verbose:
        logget.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

    tmpdir = '/tmp/submit_geant4_%d' % os.getpid()
    logger.info('Creating temporary directory %s',tmpdir)
    os.mkdir(tmpdir)

    package = os.path.abspath(args[0])
    if not os.access(package,os.R_OK):
        logger.error('Package %s cannot be read or does not exist.',args[0])
        sys.exit(9)
    if not os.path.isdir(package):
        logger.error('No directory give as package')
        sys.exit(9)
    
    package_tarball = write_tarball(package,tmpdir)
    if not package_tarball:
        logger.error('Cannot wrap up %s.',package)
        sys.exit(9)

    macro = os.path.abspath(args[1])
    if not os.access(macro,os.R_OK):
        logger.error('Macro file %s cannot be read or does not exist.',args[1])
        sys.exit(9)

    events = read_macro(macro)
    if not events:
        logger.error('Cannot find the /run/beamOn command in the macro %s.',macro)
        sys.exit(9)
        
    if options.events:
        events = options.events

    if options.split:
        subjobs = options.split
        events_per_job = events / subjobs
        events = events_per_job * subjobs
    elif options.events_per_job:
        subjobs = events / options.events_per_job
        events_per_job = options.events_per_job
        events = events_per_job * subjobs
    else:
        subjobs = 1
        events_per_job = events
   
    macro = write_macro(macro,events_per_job,tmpdir)

    logger.info('Total number of events to be simulated: %d',events)
    logger.info('Number of events per job              : %d',events_per_job)
    logger.info('Number of subjobs                     : %d',subjobs)

    job = gridrun_job(package_tarball,macro,subjobs,options.output,ce)
   
    job.submit() 
