#!/usr/bin/env python
import warnings
warnings.filterwarnings( 'ignore', category = FutureWarning )
import sys, os.path
from qt import *
qApp = QApplication( sys.argv )
from GangaGUI.Ganga_GUI_BASE import Ganga_GUI_BASE
import GangaGUI.inspector as inspector
from GangaGUI.Ganga_Log import Ganga_Log
from GangaGUI.Ganga_Scriptor import Ganga_Scriptor
from GangaGUI.Ganga_Monitor import Ganga_Monitor
from GangaGUI.Ganga_Jobs_TabWidget import Ganga_Jobs_TabWidget
from GangaGUI.miscDialogs import *
from GangaGUI.customDialogs import GUI_Configuration, Credentials_Dialog 
from GangaGUI.customEvents import *
from GangaGUI.cfg_manager import GUIConfig
from GangaGUI.License_Dialog_BASE import License_Dialog_BASE
from GangaGUI import customGUIManager
import Ganga
import Ganga.GPIDev.Credentials as Credentials
import Ganga.Utility.logging

log = Ganga.Utility.logging.getLogger('Ganga.Ganga_GUI')
QApplication.setStyle( GUIConfig.getString( 'GUI_Style' ) )


def Ganga_GUI_cleanup():
   try:
      GUIConfig.updateNow()
   except Exception, msg:
      log.error( "Error updating GUI configuration file: %s" % msg )
   else:
      log.info( "Updated GUI configuration file successfully." )
   try:
      inspector.stop_and_free_thread_pool()
   except Exception, msg:
      log.error( "Error stopping Ganga Core action threads: %s" % msg )
   else:
      log.info( "Ganga Core action threads stopped successfully." )
   try:
      Ganga.Core.MonitoringComponent.Local_GangaMC_Service.stop_and_free_thread_pool()
   except Exception, msg:
      log.error( "Error stopping monitoring component update threads: %s" % msg )
   else:
      log.info( "Ganga monitoring component update threads stopped successfully." )
   try:
      Ganga.Core.monitoring_component.stop()
      Ganga.Core.monitoring_component.join(5)
   except Exception, msg:
      log.error( "Error stopping monitoring component thread: %s" % msg )
   else:
      log.info( "Ganga monitoring component thread stopped successfully." )

   qApp.processEvents()


class TemplateAction( QObject ):
   def __init__( self, parent, template, actionParent, removeActionParent, *args ):
      QObject.__init__( self, *args )
      self.parent = parent
      self.action = QAction( actionParent, "%s_%s_TemplateAction" % ( template.name, template.id ) )
      self.removeAction = QAction( removeActionParent, "%s_%s_RemoveTemplateAction" % ( template.name, template.id ) )
      self.action.setToggleAction( 0 )
      self.action.setText( "%s %s" % ( template.id, template.name ) )
      self.action.setToolTip( "Create a new job based on the %s template (id: %s)." % ( template.name, template.id ) )
      self.removeAction.setToggleAction( 0 )
      self.removeAction.setText( "%s %s" % ( template.id, template.name ) )
      self.removeAction.setToolTip( "Remove template job %s (id: %s)." % ( template.name, template.id ) )
      self.slot = self.__buildSlot( template )
      self.slotRemove = self.__buildRemoveSlot( template )
      self.parent.connect( self.action, SIGNAL( "activated()" ), self.slot )
      self.parent.connect( self.removeAction, SIGNAL( "activated()" ), self.slotRemove )

   def __buildSlot( self, _t ):
      def _f():
         self.parent.emit( PYSIGNAL( "newJobFromTemplate()" ), ( _t.id, ) )
      return _f
   
   def __buildRemoveSlot( self, _t ):
      def _f():
         self.parent.emit( PYSIGNAL( "removeTemplate()" ), ( _t, ) )
      return _f


class Ganga_GUI( Ganga_GUI_BASE ):
   def __init__( self, parent = None, name = 'MainWindow', fl = Qt.WType_TopLevel ):
      Ganga_GUI_BASE.__init__( self, parent, name, fl )
      self.toolBar.setName( "toolBar" ) # Set name for toolbar because pyuic does 
                                        # not include the name in the 
                                        # autogenerated version of 
                                        # Ganga_GUI_BASE.py
      # Dictionary of actions to be used in other widgets.
      self.actionsDict = { 'Open' : self.jobOpenAction,
                           'New' : self.jobNewAction, 
                           'NewFromTemplate' : self.jobNewFromTemplateActionGroup,
                           'SaveAsTemplate' : self.jobSaveAsTemplateAction,
                           'Copy' : self.jobCopyAction,
                           'CopySubmit' : self.jobCopySubmitAction,
                           'Remove' : self.jobRemoveAction,
                           'Kill' : self.jobKillAction,
                           'Submit' : self.jobSubmitAction,
                           'GetOutput' : self.outputRetrieveAction,
                           'HeaderChange' : self.headerChangeAction,
                           'FolderAdd' : self.folderAdd_LF_Action,
                           'FolderRemove' : self.folderRemove_LF_Action,
                           'FolderRename' : self.folderRename_LF_Action,
                           'FolderAddJob' : self.jobAdd_LF_Action,
                           'FolderRemoveJob' : self.jobRemove_LF_Action,
                           '__PARENT__' : self }
      self.templateDict = {}
      self.setDockMenuEnabled( False )
      self.setAppropriate( self.toolBar, False )
      self.__loadGeometry()

      self.monitor = Ganga_Monitor( self.frame_CentralWidget, "Ganga_Monitor", actionsDict = self.actionsDict )
      self.frame_CentralWidget.layout().addWidget( self.monitor )
      self.log = Ganga_Log( self, "Ganga_Log" )

      inspector.Ganga.Utility.logging.bootstrap( handler=inspector.Ganga.Utility.logging.logging.StreamHandler( self.log ) )

      if self.log._getDefaultDockSettings()[0] == int( Qt.DockTornOff ):
         self.slotFloatLog()
      else:
         self.moveDockWindow( self.log, *self.log._getDefaultDockSettings() )
      self.scriptor = Ganga_Scriptor( self, "Ganga_Scriptor" )
      if self.scriptor._getDefaultDockSettings()[0] == int( Qt.DockTornOff ):
         self.slotFloatScriptor()
      else:
         self.moveDockWindow( self.scriptor, *self.scriptor._getDefaultDockSettings() )
      self.jobBuilder = Ganga_Jobs_TabWidget( self, "Job_Builder" )
      self.jobBuilder.hide()

#      self.__progressIndicatorSteps = 10
#      self.progressIndicator = QProgressBar( self.__progressIndicatorSteps, self.statusBar() )
#      Ganga.Core.jobmgr.monitoring_component.progressCallback = self.setProgress

      self.progressIndicator = QLabel( None )
      self.statusBar().addWidget( self.progressIndicator, 0, True )

      self.licenseDialog = License_Dialog_BASE( self )

      self.credentialsManagerDialog = Credentials_Dialog( self, Credentials._allCredentials )

      for _credObj in Credentials._allCredentials.itervalues():
         _credObj.inputPW_Widget = self.credentialsManagerDialog

      customGUIManager.insertConnectionSources( {'menubar_job'    : self.Job,
                                                 'menubar_folders': self.Folders,
                                                 'menubar_view'   : self.View,
                                                 'menubar_help'   : self.helpMenu,
                                                 'toolbar'        : self.toolBar,
                                                 'main'           : self} )
      customGUIManager.loadCustomGUIs()

      self.moveDockWindow( self.jobBuilder, *self.jobBuilder._getDefaultDockSettings() )
      self.guiConfigDialog = GUI_Configuration( GUIConfig, self, "GUI Configuration", True )
      self.setDockEnabled( self.log, Qt.DockLeft, False )
      self.setDockEnabled( self.log, Qt.DockRight, False )
      self.setDockEnabled( self.scriptor, Qt.DockLeft, False )
      self.setDockEnabled( self.scriptor, Qt.DockRight, False )
      self.buttonGroup_DockBtns = QButtonGroup(self.toolBar,"buttonGroup_DockBtns")
      self.buttonGroup_DockBtns.setColumnLayout(0,Qt.Vertical)
      self.buttonGroup_DockBtns.layout().setSpacing(5)
      buttonGroup_DockBtnsLayout = QHBoxLayout(self.buttonGroup_DockBtns.layout())
      buttonGroup_DockBtnsLayout.setAlignment(Qt.AlignTop)
      self.checkBox_Scriptor = QCheckBox( self.buttonGroup_DockBtns,"checkBox_Scriptor")
      self.checkBox_Scriptor.setTristate(1)
      self.checkBox_Scriptor.setState( self.__getCheckBoxState( self.scriptor ) )
      self.checkBox_Scriptor.setText( "Scriptor" )
      buttonGroup_DockBtnsLayout.addWidget( self.checkBox_Scriptor )
      self.checkBox_Scriptor.show()
      self.checkBox_Log = QCheckBox( self.buttonGroup_DockBtns,"checkBox_Log")
      self.checkBox_Log.setTristate(1)
      self.checkBox_Log.setState( self.__getCheckBoxState( self.log ) )
      self.checkBox_Log.setText( "Log" )
      self.checkBox_Log.show()
      buttonGroup_DockBtnsLayout.addWidget( self.checkBox_Log )
      self.checkBox_JobBuilder = QCheckBox( self.buttonGroup_DockBtns, "checkBox_JobBuilder")
      self.checkBox_JobBuilder.setTristate(1)
      self.checkBox_JobBuilder.setState( self.__getCheckBoxState( self.jobBuilder ) )
      self.checkBox_JobBuilder.setText( "Job Builder" )
      self.checkBox_JobBuilder.show()
      buttonGroup_DockBtnsLayout.addWidget( self.checkBox_JobBuilder )

      # Creating actions and associated slots and connections for templates
      for _t in inspector.templates:
         self.createNewTemplateAction( _t )

      # Connections ------------------
      self.connect( self.scriptor, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotScriptorPhysicalDock )
      self.connect( self.log, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotLogPhysicalDock )
      self.connect( self.jobBuilder, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotJobBuilderPhysicalDock )
      
      self.connect( self.checkBox_Scriptor, SIGNAL( "stateChanged(int)" ), self.slotScriptorDock )
      self.connect( self.checkBox_Log, SIGNAL( "stateChanged(int)" ), self.slotLogDock )
      self.connect( self.checkBox_JobBuilder, SIGNAL( "stateChanged(int)" ), self.slotJobBuilderDock )

      self.connect( self, PYSIGNAL( "removeTemplate()" ), self.slotRemoveTemplate )
      self.connect( self.scriptor, PYSIGNAL( "forceUpdate()" ), self.monitor.slotForceRefresh )
      self.connect( self.jobBuilder, PYSIGNAL( "forceUpdate()" ), self.monitor.slotForceRefresh )
      self.connect( self.monitor, PYSIGNAL( "currentJobChanged(source,id_str)" ), self.slotCurrentJobChanged )
      self.connect( self.jobBuilder, PYSIGNAL( "currentJobChanged(source,id_str)" ), self.slotCurrentJobChanged )
      self.connect( self.guiConfigDialog, PYSIGNAL( "refreshMonitor()" ), self.monitor.listView_Jobs.refresh )
      
      # Action connections
      self.connect( self.jobNewAction, SIGNAL( "activated()" ), self.slotNewJob )
      self.connect( self.jobSaveAsTemplateAction, SIGNAL( "activated()" ), self.slotSaveAsTemplateJob )
      self.connect( self.jobCopyAction, SIGNAL( "activated()" ), self.slotCopyJob )
      self.connect( self.jobCopySubmitAction, SIGNAL( "activated()" ), self.slotCopySubmitJob )
      self.connect( self.jobRemoveAction, SIGNAL( "activated()" ), self.slotRemoveJob )
      self.connect( self.jobKillAction, SIGNAL( "activated()" ), self.slotKillJob )
      self.connect( self.jobOpenAction, SIGNAL( "activated()" ), self.slotOpenJob )
      self.connect( self.jobSubmitAction, SIGNAL( "activated()" ), self.slotSubmitJob )
      self.connect( self.outputRetrieveAction, SIGNAL( "activated()" ), self.slotOutputRetrieve )
      self.connect( self.headerChangeAction, SIGNAL( "activated()" ), self.slotHeaderChange )
      self.connect( self.guiConfigAction, SIGNAL( "activated()" ), self.slotGUIConfig )
      self.connect( self.folderAdd_LF_Action, SIGNAL( "activated()" ), self.slotAddFolder )
      self.connect( self.folderRemove_LF_Action, SIGNAL( "activated()" ), self.slotRemoveFolder )
      self.connect( self.folderRename_LF_Action, SIGNAL( "activated()" ), self.slotRenameFolder )
      self.connect( self.jobAdd_LF_Action, SIGNAL( "activated()" ), self.slotAddJobToFolder )
      self.connect( self.jobRemove_LF_Action, SIGNAL( "activated()" ), self.slotRemoveJobFromFolder )
      self.connect( self.monitor.actionProgressDialog.pushButton_Close, SIGNAL( "clicked()" ), self.jobActionProgressAction, SLOT( "toggle()" ) )
      self.connect( self.monitor.actionProgressDialog, PYSIGNAL( "toggleAPAction()" ), self.jobActionProgressAction, SLOT( "toggle()" ) )

   def minimumSizeHint( self ):
      return QSize( 800,600 )

   # Broadcasts of signals ---------------------
   def slotCurrentJobChanged( self, source, id_str ):
      self.emit( PYSIGNAL( "currentJobChanged(source,id_str)" ), ( source, id_str ) )

   def slotNewJob( self ):
      self.emit( PYSIGNAL( "newJob()" ), () )

   def slotSaveAsTemplateJob( self ):
      self.emit( PYSIGNAL( "saveAsTemplateJob()" ), () )
   
   def slotCopyJob( self ):
      self.emit( PYSIGNAL( "copyJob()" ), () )
   
   def slotCopySubmitJob( self ):
      self.emit( PYSIGNAL( "copySubmitJob()" ), () )

   def slotOpenJob( self ):
      self.emit( PYSIGNAL( "openJob()" ), () )

   def slotRemoveJob( self ):
      self.emit( PYSIGNAL( "removeJob()" ), () )

   def slotKillJob( self ):
      self.emit( PYSIGNAL( "killJob()" ), () )
   
   def slotSubmitJob( self ):
      self.emit( PYSIGNAL( "submitJob()" ), () )
   
   def slotOutputRetrieve( self ):
      self.emit( PYSIGNAL( "retrieveOutput()" ), () )
   
   def slotHeaderChange( self ):
      self.emit( PYSIGNAL( "headerChange()" ), () )
   
   def slotGUIConfig( self ):
      if self.guiConfigDialog.exec_loop() == QDialog.Accepted:
         self.guiConfigDialog.updateConfig()

   def slotRemoveTemplate( self, template ):
      try:
         inspector.templates( template.id ).remove()
      except:
         miscDialogs.warningMessage( self, "Template removal failed!", "Oops!" )
      else:
         # Cannot remove action from actiongroup!
         # Hide it instead!
         self.templateDict[ self.__getActionName( template ) ].action.setVisible( False )
         self.templateDict[ self.__getActionName( template ) ].removeAction.setVisible( False )
         del self.templateDict[ self.__getActionName( template ) ]

   def slotAddFolder( self ):
      self.emit( PYSIGNAL( "folderAdd()" ), () )

   def slotRemoveFolder( self ):
      self.emit( PYSIGNAL( "folderRemove()" ), () )
   
   def slotRenameFolder( self ):
      self.emit( PYSIGNAL( "folderRename()" ), () )
   
   def slotAddJobToFolder( self ):
      self.emit( PYSIGNAL( "folderAddJob()" ), () )
   
   def slotRemoveJobFromFolder( self ):
      self.emit( PYSIGNAL( "folderRemoveJob()" ), () )

   def createNewTemplateAction( self, _t ):
      self.templateDict[ self.__getActionName( _t ) ] = TemplateAction( self, _t, self.jobNewFromTemplateActionGroup, self.templateRemoveActionGroup )

   def __getCheckBoxState( self, widget ):
      if widget.isHidden():
         return QButton.Off
      _state = widget._getDefaultDockSettings()[0]
      if _state in [ Qt.DockTornOff, Qt.DockUnmanaged ]:
         return QButton.NoChange # i.e. floating
      elif _state in [ Qt.DockMinimized ]:
         return QButton.Off
      elif _state in [ Qt.DockTop, Qt.DockBottom, Qt.DockLeft, Qt.DockRight ]:
         return QButton.On
      else:
         return QButton.Off

   def __loadGeometry( self ):
      try:
         self.setUsesBigPixmaps( GUIConfig.getBool( 'Use_Big_Pixmaps' ) )
      except:
         pass
      try:
         _wg = GUIConfig.getDict( 'Window_Geometry' )[ str( self.name() ) ]
      except KeyError:
         _wg = ( 0, 25, 820, 650 )
      self.move( _wg[0], _wg[1] )
      self.resize( _wg[2], _wg[3] )

   # Event filter that deals with closing down of Ganga
   def eventFilter( self, obj, event ):
      eType = event.type()
      if eType == QEvent.Close:
         if self.scriptor.saveFavourites() and self.jobBuilder.closeAllTabs():
            _allDocks = list( self.dockWindows( Qt.DockBottom ) ) +\
                        list( self.dockWindows( Qt.DockTop ) ) +\
                        list( self.dockWindows( Qt.DockTornOff ) )
            _d = {}
            for dWindow in _allDocks:
#               _present, _dock, _index, _nl, _extraOffset = self.getLocation( dWindow )
               _d[ str( dWindow.name() ) ] = ( self.getLocation( dWindow ), ( dWindow.x(), dWindow.y(), dWindow.width(), dWindow.height() ) )
            _d[ str( self.name() ) ] = ( self.x(), self.y(), self.width(), self.height() )
            GUIConfig.setDict( {}, 'Window_Geometry', force = True )
            GUIConfig.add_to_dict( _d, 'Window_Geometry' )
            event.accept()
         else:
#            event.ignore()
            return True
      elif eType == UPDATE_PROGRESS_EVENT:
         if isinstance( event.progress, str ):
            self.progressIndicator.setText( "%s" % event.progress )
         else:
            self.progressIndicator.setText( "%f secs to status update." % event.progress )
      return QWidget.eventFilter( self, obj, event )

   def setProgress( self, progress ):
      qt.QApplication.postEvent( self, UpdateProgress_CustomEvent( progress ) )

   def __getActionName( self, template ):
      return "%s_%s_TemplateAction" % ( template.name, template.id )

   # Dock window position slots --------------------

   def slotDockWindowPosChanged( self, dockWindow ):
      _present, _dock, _index, _nl, _extraOffset = self.getLocation( dockWindow )
      if _present:
         if _dock == Qt.DockTop:
            self.moveDockWindow( self.toolBar, Qt.DockTop, 0, True, 0 )
#            # '3' is the number of floatable windows
            self.moveDockWindow( dockWindow, Qt.DockTop, 1, True, 0 )
         if _dock == Qt.DockBottom:
            # '3' is the number of floatable windows
            self.moveDockWindow( dockWindow, Qt.DockBottom, 3, True, 0 ) 

   def slotScriptorPhysicalDock( self, state ):
      self.disconnect( self.checkBox_Scriptor, SIGNAL( "stateChanged(int)" ), self.slotScriptorDock )
      { 1 : self.slotFloatScriptorAction,
        0 : self.slotDockScriptorAction
      }[ state ]()
      self.connect( self.checkBox_Scriptor, SIGNAL( "stateChanged(int)" ), self.slotScriptorDock )

   def slotLogPhysicalDock( self, state ):
      self.disconnect( self.checkBox_Log, SIGNAL( "stateChanged(int)" ), self.slotLogDock )
      { 1 : self.slotFloatLogAction,
        0 : self.slotDockLogAction
      }[ state ]()
      self.connect( self.checkBox_Log, SIGNAL( "stateChanged(int)" ), self.slotLogDock )

   def slotJobBuilderPhysicalDock( self, state ):
      self.disconnect( self.checkBox_JobBuilder, SIGNAL( "stateChanged(int)" ), self.slotJobBuilderDock )
      { 1 : self.slotFloatJobBuilderAction,
        0 : self.slotDockJobBuilderAction
      }[ state ]()
      self.connect( self.checkBox_JobBuilder, SIGNAL( "stateChanged(int)" ), self.slotJobBuilderDock )

   def slotScriptorDock( self, tristate ):
      self.disconnect( self.scriptor, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotScriptorPhysicalDock )
      { 0 : self.slotHideScriptor,
        1 : self.slotFloatScriptor,
        2 : self.slotDockScriptor
      }[ tristate ]()
      self.connect( self.scriptor, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotScriptorPhysicalDock )

   def slotLogDock( self, tristate ):
      self.disconnect( self.log, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotLogPhysicalDock )
      { 0 : self.slotHideLog,
        1 : self.slotFloatLog,
        2 : self.slotDockLog
      }[ tristate ]()
      self.connect( self.log, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotLogPhysicalDock )

   def slotJobBuilderDock( self, tristate ):
      self.disconnect( self.jobBuilder, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotJobBuilderPhysicalDock )
      { 0 : self.slotHideJobBuilder,
        1 : self.slotFloatJobBuilder,
        2 : self.slotDockJobBuilder
      }[ tristate ]()
      self.connect( self.jobBuilder, SIGNAL( "placeChanged(QDockWindow::Place)" ), self.slotJobBuilderPhysicalDock )

   def slotDockScriptorAction( self ):
      self.checkBox_Scriptor.setState( QButton.On )
   
   def slotFloatScriptorAction( self ):
      self.checkBox_Scriptor.setState( QButton.NoChange )

   def slotHideScriptorAction( self ):
      self.checkBox_Scriptor.setState( QButton.Off )

   def slotDockLogAction( self ):
      self.checkBox_Log.setState( QButton.On )

   def slotFloatLogAction( self ):
      self.checkBox_Log.setState( QButton.NoChange )

   def slotHideLogAction( self ):
      self.checkBox_Log.setState( QButton.Off )

   def slotDockJobBuilderAction( self ):
      self.checkBox_JobBuilder.setState( QButton.On )

   def slotFloatJobBuilderAction( self ):
      self.checkBox_JobBuilder.setState( QButton.NoChange )

   def slotHideJobBuilderAction( self ):
      self.checkBox_JobBuilder.setState( QButton.Off )

   def slotDockScriptor( self ):
      self.scriptor._setLastGeometry()
      self.scriptor.dock()

   def slotFloatScriptor( self ):
      lg = self.scriptor._getLastGeometry()
      self.scriptor.dock()
      self.scriptor.undock()
      self.scriptor.hide()
      self.scriptor.move( lg[0], lg[1] )
      self.scriptor.resize( lg[2], lg[3] )
      self.scriptor.show()

   def slotHideScriptor( self ):
      self.moveDockWindow( self.scriptor, Qt.DockMinimized )

   def slotDockLog( self ):
      self.log._setLastGeometry()
      self.log.dock()

   def slotFloatLog( self ):
      lg = self.log._getLastGeometry()
      self.log.dock()
      self.log.undock()
      self.log.hide()
      self.log.move( lg[0], lg[1] )
      self.log.resize( lg[2], lg[3] )
      self.log.show()

   def slotHideLog( self ):
      self.moveDockWindow( self.log, Qt.DockMinimized )

   def slotDockJobBuilder( self ):
      self.jobBuilder._setLastGeometry()
      self.jobBuilder.dock()

   def slotFloatJobBuilder( self ):
      lg = self.jobBuilder._getLastGeometry()
      if not self.jobBuilder.isHidden():
         self.jobBuilder.dock()
         self.jobBuilder.undock()
      self.jobBuilder.hide()
      self.jobBuilder.move( lg[0], lg[1] )
      self.jobBuilder.resize( lg[2], lg[3] )
      self.jobBuilder.show()

   def slotHideJobBuilder( self ):
      self.moveDockWindow( self.jobBuilder, Qt.DockMinimized )

   def slotShowMainToolbar( self, x ):
      if x:
         self.toolBar.show()
      else:
         self.toolBar.hide()

   def slotShowAPDialog( self, enabled ):
      if enabled:
         self.monitor.actionProgressDialog.show()
      else:
         self.monitor.actionProgressDialog.close()
   
   def slotInvokeCMDialog( self ):
      self.credentialsManagerDialog.ask()

   def helpLicense( self ):
      try:
         _gangaPythonPath = os.path.dirname( os.path.dirname( Ganga.__file__ ) )
         licenseInfo = file( os.path.join( _gangaPythonPath, '..', 'LICENSE_GPL' ) ).read()
      except Exception, msg:
         log.error( "Error reading license information: %s" % msg )
         licenseInfo = 'No information available.'
      self.licenseDialog.textEdit.setText( licenseInfo )
      self.licenseDialog.exec_loop()


def main():
   w = Ganga_GUI()
   qApp.setMainWidget( w )
   w.show()
   qApp.connect( qApp, SIGNAL( "lastWindowClosed()" ), Ganga_GUI_cleanup )
   qApp.exec_loop()
   del w


if __name__ == "__main__":
   main()
