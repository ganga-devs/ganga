#!/usr/bin/env python3
import os
import sys
import subprocess
import time
import multiprocessing
from pathlib import Path
from os.path import dirname, join

def mp_worker(name):
    if not Path(join(dirname(name), '__syslog__')).is_file():
        print(f'START: {name} '+ time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())))
        subprocess.run(['python3', name])
    else:
        print(f'SKIPPING: {name} '+ time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())))

# Make sure that the wrapper (spawned process) is detached from Ganga session
# the process will not receive Control-C signals
# using fork  and doing setsid() before  exec would probably  be a bit
# better (to avoid  slim chance that the signal  is propagated to this
# process before setsid is reached)
# this is only enabled if the first argument is 'subprocess' in order to enable
# running this script by hand from outside ganga (which is sometimes useful)
if len(sys.argv)>1 and sys.argv[1] == 'subprocess':
    os.setsid()
        
workdir = ###WORKDIR###
batch_size = ###BATCHSIZE###
    
scriptnames_g = Path(workdir).glob('*/*/__jobscript__')

outdir = join(workdir,'output')
os.mkdir(outdir)
statusfilename = join(outdir,'__jobstatus__')

try:
    statusfile=open(statusfilename,'w')
except IOError as x:
    print('ERROR: not able to write a status file: ', statusfilename)
    print('ERROR: ',x)
    raise

line='START: '+ time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())) + os.linesep
statusfile.writelines(line)
statusfile.flush()

sys.stdout=open(join(outdir,'__syslog__'),'w')
sys.stderr=sys.stdout

print(f'Running with a batch size of {batch_size}')
pool = multiprocessing.Pool(batch_size)
pool.map(mp_worker, scriptnames_g)

sys.stdout=sys.__stdout__
sys.stderr=sys.__stderr__

line='STOP: '+time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())) + os.linesep
statusfile.writelines(line)
statusfile.close()
sys.exit()
